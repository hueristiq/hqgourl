package main

import (
	"bufio"
	"fmt"
	"net/http"
	"os"
	"regexp"
	"sort"
	"strings"
	"text/template"

	"github.com/hueristiq/hqgolog"
	"github.com/spf13/pflag"
)

var (
	output string

	tmpl = template.Must(template.New("schemes").Parse(`// This file is autogenerated by https://github.com/hueristiq/hqgourl/blob/main/generate/tlds/main.go. Please do not edit manually.

package tlds

// TLDs is a sorted list of public TLDs and eTLDs.
// The list is fetched from:
//   - https://data.iana.org/TLD/tlds-alpha-by-domain.txt
//   - https://publicsuffix.org/list/public_suffix_list.dat
var TLDs = []string{
{{range $_, $TLD := .TLDs}}` + "\t`" + `{{$TLD}}` + "`" + `,
{{end}}}
`))
)

func init() {
	pflag.StringVarP(&output, "output", "o", "", "")

	pflag.CommandLine.SortFlags = false
	pflag.Usage = func() {
		h := "USAGE:\n"
		h += "  tlds [OPTIONS]\n"

		h += "\nOPTIONS:\n"
		h += " -o, --output string                 output package file path\n"

		fmt.Fprintln(os.Stderr, h)
	}

	pflag.Parse()
}

func main() {
	hqgolog.Info().Msgf("Generating %s...", output)

	TLDs, err := getTLDsFromIANA()
	if err != nil {
		hqgolog.Fatal().Msgf(err.Error())
	}

	eTLDs, err := getEffectiveTLDsFromPublicSuffix()
	if err != nil {
		hqgolog.Fatal().Msgf(err.Error())
	}

	TLDs = append(TLDs, eTLDs...)

	sort.Strings(TLDs)

	f, err := os.Create(output)
	if err != nil {
		hqgolog.Fatal().Msgf(err.Error())
	}

	defer f.Close()

	if err = tmpl.Execute(f, struct {
		TLDs []string
	}{
		TLDs: remDuplicates(TLDs),
	}); err != nil {
		hqgolog.Fatal().Msgf(err.Error())
	}
}

func getTLDsFromIANA() (TLDs []string, err error) {
	TLDs = []string{}

	var res *http.Response

	res, err = http.Get("https://data.iana.org/TLD/tlds-alpha-by-domain.txt")
	if err != nil {
		return
	}

	defer res.Body.Close()

	re := regexp.MustCompile(`^[^#]+$`)

	scanner := bufio.NewScanner(res.Body)

	for scanner.Scan() {
		line := scanner.Text()

		line = strings.TrimSpace(line)
		line = strings.ToLower(line)

		TLD := re.FindString(line)

		if TLD == "" || strings.HasPrefix(TLD, "xn--") {
			continue
		}

		TLDs = append(TLDs, TLD)
	}

	if err = scanner.Err(); err != nil {
		return
	}

	return
}

// remDuplicates
// removes duplicate elements from a slice of any type that satisfies the comparable constraint.
func remDuplicates[T comparable](slice []T) []T {
	keys := make(map[T]bool)

	var list []T

	for _, entry := range slice {

		if _, exists := keys[entry]; !exists {
			keys[entry] = true

			list = append(list, entry)
		}
	}

	return list
}

func getEffectiveTLDsFromPublicSuffix() (eTLDs []string, err error) {
	eTLDs = []string{}

	var res *http.Response

	res, err = http.Get("https://publicsuffix.org/list/effective_tld_names.dat")
	if err != nil {
		return
	}

	defer res.Body.Close()

	scanner := bufio.NewScanner(res.Body)

	for scanner.Scan() {
		line := scanner.Text()

		line = strings.TrimSpace(line)

		if strings.HasPrefix(line, "// ===BEGIN PRIVATE DOMAINS") {
			break
		}

		if strings.HasPrefix(line, "//") {
			continue
		}

		TLD := line

		TLD = strings.ReplaceAll(TLD, "*.", "")
		TLD = strings.ReplaceAll(TLD, "!", "")

		if TLD == "" {
			continue
		}

		eTLDs = append(eTLDs, TLD)
	}

	if err = scanner.Err(); err != nil {
		return
	}

	return
}
